       |import std.stdio;
       |import std.conv;
       |import std.algorithm.sorting : sort;
       |import std.string;
       |
       |// Define los diferentes casos de tipos de datos que 
       |// se pueden simular en el programa
       |enum TypeKind {
       |    Atomic, 
       |    Struct, 
       |    Union
       |}
       |
       |// Define la estructura donde se guardarán todos estos
       |// tipos de datos, hay campos exclusivos, pero son tan pocos
       |// que no vale la pena crear estructuras propias para cada uno,
       |// para la legibilidad del código resulta mejor juntarlos todos
       |struct TypeSum
       |{   
       |    TypeKind kind;
       |    string name;
       |    int size = 0;
       |    int alignment = 0;
       |    int heuristic_wasted = 0; // Exclusivo para caso de Struct
       |    int[] memory = [];
       |    string[] types = []; // Es vacío exclusivamente cuando se trata de un tipo atómico 
       |}
       |
       |struct HeuristicAnswer
       |{
       |    int wasted_bytes;
       |    int total_size;
       |    int alignment;
       |    int[] memory = []; 
       |}
       |
       |TypeSum[string] global_types;
       |
       |// Define la estructura para los tipos ya colocados en memoria de
       |// un struct, se usa para el cálculo de espacio ocupado por un struct en memoria
       |struct PlacedType 
       |{
       |    string name;
       |    TypeSum ts;
       |    size_t offset;
       |}
       |
       |// Define los huecos de fragmentación interna de la memoria reservada para un struct,
       |// es útil para el cálculo de memoria total usada por un struct y memoria desperdiciada
       |struct Hole 
       |{
       |    size_t start;
       |    size_t end;
       |}
       |
       |// Estructura para enviar respuestas de procesamiento de los comandos al
       |// hilo de ejecución principal, para hacerle saber si debe finalizar, 
       |// qué mensaje debe enviar y el estado del diccionario de tipos actual 
       |struct OutputData
       |{
       |    bool exit;
       |    string output;
       |}
       |
       |// Función que intenta parsear a entero, pero al fallar lanza una excepción
       |int parse_to_int(string str_num)
       |{
     14|    int num;
       |    try{
     14|        num = to!int(str_num);
     12|        if(num < 0){
      1|            throw new Exception("");
       |        }
     11|        return num;
       |    } catch(Exception e){
      3|        throw new Exception("Los argumentos tienen tipo inválido, deben ser enteros positivos.");
       |    }
       |}
       |
       |// Función que calcula el mínimo entero múltiplo de a que es mayor a x, 
       |// sirve para saber la próxima posición de un tipo en memoria según alineación.
       |size_t alignTo(size_t x, size_t a)
       |{
     18|    return ((x + a - 1) / a) * a;
       |}
       |
       |// Función que verifica que todos los tipos en una lista estén declarados previamente
       |// en el diccionario general de tipos
       |bool is_type_list_valid(string[] type_list)
       |{
     55|    foreach (x; type_list){
     13|        if(!(x in global_types)){
      4|            return false;
       |        }
       |    }
      4|    return true;
       |}
       |
       |// =============================================================================================
       |// Función: create_atomic_type
       |// =============================================================================================
       |// Función que permite crear un tipo atómico, verifica que el tipo no exista previamente.
       |// En caso de no existir aún, entonces lo agrega al diccionario de tipos general del programa
       |// =============================================================================================
       |void create_atomic_type(string name, int size, int alignment)
       |{
      9|    if(name in global_types){
      2|        throw new Exception("El tipo " ~ name ~ " ya existe.");
       |    }
       |
      7|    TypeSum new_type;
      7|    new_type.kind = TypeKind.Atomic;
      7|    new_type.name = name;
      7|    new_type.size = size;
      7|    new_type.alignment = alignment;
       |
      7|    int[] memory_arr;
      7|    memory_arr.length = size;
      7|    memory_arr[] = 1;
      7|    new_type.memory = memory_arr;
       |
      7|    global_types[name] = new_type;
       |
       |
       |
      7|    return;
       |}
       |
       |// =============================================================================================
       |// Función: create_struct_type
       |// =============================================================================================
       |// Función que crea un elemento de tipo struct. Verifica que no existe un tipo con ese nombre.
       |// En caso de no existir, entonces agrega el elemento al diccionario de tipos general, este
       |// directamente debe cuantificar el tamaño y el desperdicio, pero debe escoger si lo hace sin 
       |// empaquetar, empaquetando o con una heurística. En este caso, se decidió usar la heurística
       |// para calcular el tamaño para que otros tipos de datos puedan usarlo.
       |// La alineación que termina teniendo el tipo struct es la misma alineación que su primer bloque.
       |// =============================================================================================
       |void create_struct_type(string name, string[] struct_types)
       |{
      6|    if(name in global_types){
      2|        throw new Exception("El tipo " ~ name ~ " ya existe.");
       |    }
       |
      4|    if(!is_type_list_valid(struct_types)){
      2|        throw new Exception("Algún tipo definido para el struct no existe.");
       |    }
       |
      2|    TypeSum new_type;
      2|    new_type.kind = TypeKind.Struct;
      2|    new_type.name = name;
      2|    new_type.types = struct_types;
       |
      2|    HeuristicAnswer result = best_fit_heuristic_for_layout(struct_types);
       |
      2|    new_type.size = result.total_size;
      2|    new_type.heuristic_wasted = result.wasted_bytes;
       |
      2|    new_type.alignment = result.alignment;
      2|    new_type.memory = result.memory;
       |
      2|    global_types[name] = new_type;
      2|    return;
       |}
       |
       |// =============================================================================================
       |// Función: create_union_type
       |// =============================================================================================
       |// Función que crea un elemento de tipo union. Verifica que no existe un tipo con ese nombre.
       |// En caso de no existir, entonces agrea este tipo al diccionario de tipos generales del programa.
       |// Para el cálculo del tamaño, simplemente se queda con el tipo interno de mayor tamaño. 
       |// Para la alineación, toma el mínimo común múltiplo de las alineaciones de los tipos internos.
       |// =============================================================================================
       |void create_union_type(string name, string[] union_types)
       |{
      6|    if(name in global_types){
      2|        throw new Exception("El tipo " ~ name ~ " ya existe.");
       |    }
       |
      4|    if(!is_type_list_valid(union_types)){
      2|        throw new Exception("Algún tipo definido para la unión no existe.");
       |    }
       |
      2|    TypeSum new_type;
      2|    new_type.kind = TypeKind.Union;
      2|    new_type.name = name;
      2|    new_type.types = union_types;
       |
       |    // Calcular el tamaño de el tipo suma, en este caso, debe ser el tamaño del tipo que tiene mayor tamaño
      2|    int max_size = 0;
     18|    foreach(type; union_types){
      4|        if(global_types[type].size > max_size){
      3|            max_size = global_types[type].size;
       |        }
       |    }
       |
      2|    new_type.size = max_size;
       |
      2|    int[] memory_arr;
      2|    memory_arr.length = max_size;
      2|    memory_arr[] = 1;
      2|    new_type.memory = memory_arr;
       |
       |    // Calcular la alineación, será el mínimo común múltiplo entre las alineaciones de los tipos internos
      2|    int union_lcm = global_types[union_types[0]].alignment;
     12|    foreach(type; union_types[1..$]){
      2|        union_lcm = (union_lcm / gcd(union_lcm, global_types[type].alignment)) * global_types[type].alignment;
       |    }
       |
      2|    new_type.alignment = union_lcm;
      2|    global_types[name] = new_type;
       |    
      2|    return;
       |}
       |
       |
       |// Función que calcula el máximo común divisor entre dos números
       |int gcd(int a, int b) 
       |{
      5|    while (b != 0) {
      3|        int t = b;
      3|        b = a % b;
      3|        a = t;
       |    }
      2|    return a;
       |}
       |
       |// =============================================================================================
       |// Función: not_packed_method_for_layout
       |// =============================================================================================
       |// Función que calcula el tamaño total utilizado y la cantidad de desperdicio de un tipo struct, 
       |// a través del uso de la técnica vista en la teoría de no empaquetado. Básicamente,
       |// coloca los bloques de tipo en el orden declarado, respetando su alineación.
       |// =============================================================================================
       |HeuristicAnswer not_packed_method_for_layout(string[] types)
       |{
      1|    TypeSum[] ordered;
     15|    foreach(name; types) ordered ~= global_types[name];
       |
      1|    Hole[] holes;
      1|    size_t struct_size = 0;
       |
      1|    PlacedType[] result;
     12|    foreach(ts; ordered){
       |        
      3|        size_t aligned = alignTo(struct_size, ts.alignment);
       |
      3|        result ~= PlacedType(ts.name, ts, aligned);
       |
      3|        if (aligned > struct_size)
      2|            holes ~= Hole(struct_size, aligned);
       |
      3|        struct_size = aligned + ts.size;
       |    }
       |
      1|    size_t total_size = struct_size;
      1|    size_t wasted_bytes = 0;
      9|    foreach (h; holes)
      2|        wasted_bytes += (h.end - h.start);
       |    
      1|    int[] memoryMap;
      1|    memoryMap.length = total_size;
      1|    memoryMap[] = 0; // inicializar todo en 0
       |
     12|    foreach (p; result)
       |    {
      3|        size_t start = p.offset;
      3|        size_t end   = p.offset + p.ts.size;
       |
       |        // Marcar bytes ocupados
     26|        for (size_t i = start; i < end; i++)
     10|            memoryMap[i] = 1;
       |    }
       |
      1|    return HeuristicAnswer(to!int(wasted_bytes), to!int(total_size), 0, memoryMap);
       |
       |}  
       |
       |string get_memory_layout(int[] memory_arr){
      5|    int i = 0;
      5|    int index = 0;
      5|    string memory_display = "";
      5|    int size = memory_arr.length;
      5|    int last_position = alignTo(size, 4);
      5|    int max_index = 1;
     13|    while(max_index < last_position)
       |    {
      8|        max_index *= 10;
       |    }
     85|    while(i % 4 != 0 || i < last_position)
       |    {
     60|        if(i % 4 == 0)
       |        {
     30|            int index_space = (index == 0) ? 1 : index;
     15|            int counter = 0;
     39|            while(index_space < max_index){
     24|                index_space = index_space * 10;
     24|                counter += 1;
       |            }
     15|            char[] spaced_index;
     15|            spaced_index.length = counter;
     15|            spaced_index[] = ' ';
       |            
     30|            memory_display ~= (i == 0) ? "      " ~ spaced_index ~ to!string(index) ~ " |" : "\n      " ~ spaced_index ~ to!string(index) ~ " |";
     15|            index += 4;
       |        }
       |
     60|        if(i >= size)
       |        {
     10|            memory_display ~= " 0 ";
       |        } else{
     50|            memory_display ~= " " ~ to!string(memory_arr[i]) ~ " ";
       |        }
       |
     60|        if( (i + 1) % 4 == 0)
       |        {
     15|            memory_display ~= "|";
       |        } 
       |
     60|        i += 1;
       |    }
      5|    return memory_display;
       |}
       |
       |
       |// =============================================================================================
       |// Función: get_type_description
       |// =============================================================================================
       |// Función que verifica la existencia de un tipo y, en caso de existir, devuelve una 
       |// descripción personalizada según si el tipo es struct, union o atómico.
       |// Para el caso de struct devuelve el tamaño y el desperdicio de Bytes bajo tres enfoques distintos:
       |//    1. No empaquetado
       |//    2. Empaquetado
       |//    3. Utilizando una heurística para intentar llegar a un caso óptimo
       |// (Realmente, los compiladores utilizan la opción 3 cuando el struct está compuesto por pocos 
       |//  tipos y no usan una heurística, sino un algoritmo correcto que resuelve el problema de la
       |//  disposición de memoria óptimo, esto está mejor explicado en el PDF técnico). 
       |// =============================================================================================
       |string get_type_description(string name)
       |{
      4|    if(!(name in global_types)){
      1|        throw new Exception("El tipo " ~ name ~ " no existe.");
       |    }
      3|    string output = "";
      3|    switch (global_types[name].kind){
      1|        case TypeKind.Atomic:
      1|            output ~= "Descripción de " ~ name ~ ":\n";
      1|            output ~= "    Tipo: Atómico.\n";
      1|            output ~= "    Tamaño: " ~ to!string(global_types[name].size) ~ " Bytes\n";
      1|            output ~= "    Alineación: " ~ to!string(global_types[name].alignment) ~ "\n";
       |            
      1|            string memory_display = get_memory_layout(global_types[name].memory);
      1|            output ~= "    Disposición de memoria: \n";
      1|            output ~= "    =========================== \n";
      1|            output ~= memory_display;
      1|            output ~= "\n    =========================== \n";
       |
      1|            output ~= "    Desperdicio: 0B";
      1|            return output;
      1|        case TypeKind.Union:
      1|            output ~= "Descripción de " ~ name ~ ":\n";
      1|            output ~= "    Tipo: Unión.\n";
      1|            output ~= "    Campos: \n";
      9|            foreach(type; global_types[name].types){
      2|                output ~= "       " ~ global_types[type].name ~ " | " ~ to!string(global_types[type].size) ~ " Bytes | " ~ to!string(global_types[type].alignment) ~ " de alineación.\n";
       |            }
      1|            output ~= "    Tamaño: " ~ to!string(global_types[name].size) ~ " Bytes\n";
      1|            output ~= "    Alineación: " ~ to!string(global_types[name].alignment) ~ "\n";
      1|            output ~= "    Desperdicio: Depende del tipo a tiempo de ejecución\n";
      9|            foreach(type; global_types[name].types){
      2|                output ~= "       " ~ global_types[type].name ~ " -> " ~ to!string(global_types[name].size - global_types[type].size) ~ " Bytes.\n";
       |            }
       |
      1|            string memory_display = get_memory_layout(global_types[name].memory);
      1|            output ~= "    Disposición de memoria: \n";
      1|            output ~= "    =========================== \n";
      1|            output ~= memory_display;
      1|            output ~= "\n    =========================== \n";
       |
      1|            return output;
      1|        case TypeKind.Struct:
      1|            output ~= "Descripción de " ~ name ~ ":\n";
      1|            output ~= "    Tipo: Struct.\n";
      1|            output ~= "    Campos: \n";
      1|            int total_size = 0;
     12|            foreach(type; global_types[name].types){
      3|                output ~= "        " ~ global_types[type].name ~ " | " ~ to!string(global_types[type].size) ~ " Bytes | " ~ to!string(global_types[type].alignment) ~ " de alineación.\n";
      3|                total_size += global_types[type].size;
       |            }
      1|            output ~= "    Tamaño y desperdicio\n";
      1|            HeuristicAnswer not_packet_result = not_packed_method_for_layout(global_types[name].types);
       |
      1|            output ~= "    No empaquetado -- Tamaño: " ~ to!string(not_packet_result.total_size) ~ " Bytes\n    Desperdicio: " ~ to!string(not_packet_result.wasted_bytes) ~ " Bytes.\n";
       |            
      1|            string memory_display = get_memory_layout(not_packet_result.memory);
      1|            output ~= "    Disposición de memoria: \n";
      1|            output ~= "    =========================== \n";
      1|            output ~= memory_display;
      1|            output ~= "\n    =========================== \n";
       |
      1|            output ~= "    Empaquetado -- Tamaño: " ~ to!string(total_size) ~ " Bytes\n    Desperdicio: 0 Bytes.\n";
       |            
      1|            int[] memory_arr;
      1|            memory_arr.length = total_size;
      1|            memory_arr[] = 1;
      1|            memory_display = get_memory_layout(memory_arr);
      1|            output ~= "    Disposición de memoria: \n";
      1|            output ~= "    =========================== \n";
      1|            output ~= memory_display;
      1|            output ~= "\n    =========================== \n";
       |            
      1|            output ~= "    Heurística: " ~ to!string(global_types[name].size) ~ " Bytes y " ~ to!string(global_types[name].heuristic_wasted) ~ " Bytes desperdiciados.";
      1|            memory_display = get_memory_layout(global_types[name].memory);
      1|            output ~= "\n    Disposición de memoria: \n";
      1|            output ~= "    =========================== \n";
      1|            output ~= memory_display;
      1|            output ~= "\n    =========================== \n";
       |            
      1|            return output;
       |
0000000|        default:
0000000|            throw new Exception("Error: Ocurrió un error inesperado.");
       |    }
       |
       |}         
       |
       |
       |// =============================================================================================
       |// Función: best_fit_heuristic_for_layout
       |// =============================================================================================
       |// Función que simula una especie de BestFit tradicional, este primero ordena los tipos según
       |// su alineación, en caso de tener misma alineación, entonces ordena por tamaño. Se disponen en 
       |// memoria comenzando entonces por los de mayor alineación, intentando hacer un BestFit cuando
       |// se generan huecos en memoria; es decir, si un bloque se puede colocar en más de un hueco,
       |// entonces se coloca en el que se encuentre más estrecho, el que deje un hueco de menor tamaño.
       |// Esta heurística consigue la solución óptima en muchos casos, pero no es infalible, sin embargo,
       |// es mucho más barata en términos de complejidad que la función que resuelve el problema el 
       |// total de las veces. 
       |// En el PDF técnico se habla de los dos enfoques y se entiende por qué decidí esta opción
       |// =============================================================================================
       |HeuristicAnswer best_fit_heuristic_for_layout(string[] types)
       |{
       |    // 1) ordenar tipos
      2|    TypeSum[] ordered;
     26|    foreach(name; types) ordered ~= global_types[name];
       |
      2|    ordered.sort!((a, b) =>
      7|        (a.alignment > b.alignment) ||
     10|        (a.alignment == b.alignment && a.size > b.size)
       |    );
       |
       |    // writeln("Este es ordered:");
       |    // writeln(ordered);
       |
      2|    Hole[] holes;
      2|    size_t struct_size = 0;
       |
      2|    PlacedType[] result;
       |
     21|    foreach(ts; ordered)
       |    {
      5|        size_t best_hole_index = 0;
      5|        bool found = false;
      5|        size_t best_fit_padding = size_t.max;
      5|        size_t best_aligned_offset;
       |
       |        // Intentar colocarlo en cada hueco
     19|        foreach(i, h; holes)
       |        {
      1|            size_t aligned = alignTo(h.start, ts.alignment);
      1|            size_t diff = h.end - aligned;
       |
      1|            if (diff >= ts.size)
       |            {
0000000|                size_t leftover = diff - ts.size;
       |
0000000|                if (leftover < best_fit_padding) {
0000000|                    best_fit_padding = leftover;
0000000|                    best_hole_index = i;
0000000|                    found = true;
0000000|                    best_aligned_offset = aligned;
       |                }
       |            }
       |        }
       |        // writeln("Huecos: ");
       |        // writeln(holes);
       |        // writeln("Este es el best_hole_index: " ~ to!string(best_hole_index));
      5|        if (found)
       |        {
0000000|            result ~= PlacedType(ts.name, ts, best_aligned_offset);
       |
0000000|            Hole h = holes[best_hole_index];
       |
       |            // Partir hueco según donde cayó
0000000|            Hole[] new_holes;
       |
0000000|            if (best_aligned_offset > h.start)
0000000|                new_holes ~= Hole(h.start, best_aligned_offset);
       |
0000000|            if (best_aligned_offset + ts.size < h.end)
0000000|                new_holes ~= Hole(best_aligned_offset + ts.size, h.end);
       |
0000000|            if(best_hole_index == 0 && holes.length == 1){
0000000|                holes = new_holes;
       |            } else{
0000000|                holes[best_hole_index .. best_hole_index+1] = new_holes;
       |            }
       |            
       |        }
       |        else
       |        {
       |            // Colocar al final
      5|            size_t aligned = alignTo(struct_size, ts.alignment);
       |
      5|            result ~= PlacedType(ts.name, ts, aligned);
       |
      5|            if (aligned > struct_size)
      2|                holes ~= Hole(struct_size, aligned);
       |
      5|            struct_size = aligned + ts.size;
       |        }
       |    }
       |
      2|    size_t total_size = struct_size;
      2|    size_t wasted_bytes = 0;
     14|    foreach (h; holes) wasted_bytes += (h.end - h.start);
       |
      2|    int[] memoryMap;
      2|    memoryMap.length = total_size;
      2|    memoryMap[] = 0; // inicializar todo en 0
       |
     21|    foreach (p; result)
       |    {
      5|        size_t start = p.offset;
      5|        size_t end   = p.offset + p.ts.size;
       |
       |        // Marcar bytes ocupados
     38|        for (size_t i = start; i < end; i++)
     14|            memoryMap[i] = 1;
       |    }
       |    
      2|    return HeuristicAnswer(to!int(wasted_bytes), to!int(total_size), ordered[0].alignment, memoryMap);
       |}
       |
       |
       |// =============================================================================================
       |// Función: parse_entry
       |// =============================================================================================
       |// Función que parsea la entrada y hace el llamado de las funciones correspondientes según
       |// comando. Esta también devuelve el estado de salida del programa, el mensaje de salida del
       |// programa y el nuevo estado del diccionario de tipos general del programa.
       |// =============================================================================================
       |OutputData parse_entry(string[] entries_arr){
     21|    float result;
     21|    string result_str;
       |
       |    // Hacemos un toLower para permitir que el usuario escriba eval o eVal o EVAL 
       |    // o cualquier combinación entre mayúsculas y minúsculas
     21|    switch(toLower(entries_arr[0])){
      7|        case "atomico":
       |            
      7|            if(entries_arr.length != 4){
      1|                throw new Exception("Error: Mal uso del comando 'atómico'.");
       |            }
       |
      6|            int size = parse_to_int(entries_arr[2]);
      5|            int alignment = parse_to_int(entries_arr[3]);
       |
      5|            create_atomic_type(entries_arr[1], size, alignment);
       |
      4|            return OutputData(false, "Tipo atómico creado correctamente");
       |        
      3|        case "union":
       |
      3|            create_union_type(entries_arr[1], entries_arr[2..$]);
      1|            return OutputData(false, "Tipo union creado correctamente");
       |
      3|        case "struct":
       |
      3|            create_struct_type(entries_arr[1], entries_arr[2..$]);
      1|            return OutputData(false, "Tipo struct creado correctamente");
       |
      4|        case "describir":
       |
      4|            if(entries_arr.length != 2){
0000000|                throw new Exception("Error: Mal uso del comando 'describir'.");
       |            }
      4|            string description = get_type_description(entries_arr[1]);
      3|            return OutputData(false, description);
       |
      1|        case "ayuda":
      1|            string[] help_array = [
       |                "ATOMICO <nombre> <representación> <alineación> -> \n    Evalúa la expresión [expr] que debe está en forma prefija.\n",
       |                "STRUCT <nombre> [<tipo>] -> \n    Define un registro cuyos campos son tipos existentes.\n",
       |                "UNION <nombre> [<tipo>] -> \n    Define un registro variante cuyos campos comparten el mismo espacio.\n",
       |                "DESCRIBIR <nombre> -> \n    Muestra el tamaño, alineación y bytes desperdiciados del tipo.\n",
       |                "SALIR -> \n    Termina el programa."
       |            ];
      1|            return OutputData(false, help_array[0] ~ help_array[1] ~ help_array[2] ~ help_array[3] ~ help_array[4]);
      1|        case "salir":
      1|            return OutputData(true, "Saliendo...");
      2|        default:
      2|            throw new Exception("Error: Comando desconocido.");
       |    }
       |}
       |
       |
       |void main(){
       |
0000000|    while(true){
0000000|        write("> ");
0000000|        string entry = readln();
0000000|        entry = entry[0..$-1];
       |        // Se dividen los elementos enviados por medio de un espacio
0000000|        string[] entries_arr = entry.split(" ");
       |
0000000|        if(entries_arr.length == 0){
0000000|            writeln("Error: Debe ingresar un comando.");
0000000|            continue;
       |        }
       |
       |        // Utilizamos try catch para enviar excepciones y sean reconocidas en el catch sin tener que
       |        // establecer métodos para salir de las funciones llamadas y demás.
       |        try{
0000000|            OutputData output = parse_entry(entries_arr);
0000000|            writeln(output.output);
0000000|            if(output.exit){
0000000|                break;
       |            }
       |
       |        } catch (Exception e){
0000000|            writeln("Error: ", e.msg);
       |        }
       |    }
       |}
       |
       |unittest {
       |    import std.stdio;
       |
       |    // Limpiar diccionario para que las pruebas sean deterministas
       |
       |    // =============================================================
       |    // parse_to_int
       |    // =============================================================
      1|    assert(parse_to_int("10") == 10);
       |
      1|    bool caught = false;
      2|    try { parse_to_int("-1"); } catch (Exception e) { caught = true; }
      1|    assert(caught);
       |
      1|    caught = false;
      2|    try { parse_to_int("abc"); } catch (Exception e) { caught = true; }
      1|    assert(caught);
       |
       |    // =============================================================
       |    // alignTo
       |    // =============================================================
      1|    assert(alignTo(0, 4) == 0);
      1|    assert(alignTo(1, 4) == 4);
      1|    assert(alignTo(4, 4) == 4);
      1|    assert(alignTo(5, 4) == 8);
       |
       |    // =============================================================
       |    // create_atomic_type
       |    // =============================================================
      1|    create_atomic_type("u8", 1, 1);
      1|    assert("u8" in global_types);
      1|    assert(global_types["u8"].size == 1);
      1|    assert(global_types["u8"].alignment == 1);
      1|    assert(global_types["u8"].kind == TypeKind.Atomic);
       |
      1|    caught = false;
      2|    try { create_atomic_type("u8", 1, 1); } catch (Exception e) { caught = true; }
      1|    assert(caught);
       |
       |    // =============================================================
       |    // create_struct_type
       |    // =============================================================
       |
       |    // Definir algunos tipos básicos para usarlos en structs
      1|    create_atomic_type("u16", 2, 2);
      1|    create_atomic_type("u32", 4, 4);
       |
       |    // Caso válido
      1|    create_struct_type("Punto", ["u16", "u16"]);
      1|    assert("Punto" in global_types);
      1|    assert(global_types["Punto"].kind == TypeKind.Struct);
      1|    assert(global_types["Punto"].types == ["u16", "u16"]);
      1|    assert(global_types["Punto"].size > 0);  // depende de tu heurística
      1|    assert(global_types["Punto"].heuristic_wasted >= 0);
       |
       |    // Caso: tipo ya existe
      1|    caught = false;
      2|    try { create_struct_type("Punto", ["u16", "u16"]); } catch (Exception e) { caught = true; }
      1|    assert(caught);
       |
       |    // Caso: tipo interno inexistente
      1|    caught = false;
      2|    try { create_struct_type("StructX", ["noexiste"]); } catch (Exception e) { caught = true; }
      1|    assert(caught);
       |
       |    // =============================================================
       |    // create_union_type
       |    // =============================================================
       |
      1|    create_union_type("Numero", ["u8", "u32"]);
      1|    assert("Numero" in global_types);
      1|    assert(global_types["Numero"].kind == TypeKind.Union);
      1|    assert(global_types["Numero"].size == 4);        // max(u8=1, u32=4)
      1|    assert(global_types["Numero"].alignment == 4);   // mcm(1,4) = 4
       |
       |    // Crear unión inválida (tipo inexistente)
      1|    caught = false;
      2|    try { create_union_type("BadUnion", ["u999"]); } catch (Exception e) { caught = true; }
      1|    assert(caught);
       |
       |    // Crear unión repetida
      1|    caught = false;
      2|    try { create_union_type("Numero", ["u8"]); } catch (Exception e) { caught = true; }
      1|    assert(caught);
       |
      1|    global_types.clear();
       |
      1|    OutputData data = parse_entry(["atomico", "int", "2", "2"]);
      1|    assert(data.output == "Tipo atómico creado correctamente");
       |
       |    // ---- Caso: atómico repetido ----
      1|    caught = false;
       |    try {
      1|        parse_entry(["atomico", "int", "2", "2"]);
       |    } catch (Exception e) {
      1|        caught = true;
       |    }
      1|    assert(caught);
       |
       |    // ---- Caso: atómico inválido (tamaño no numérico) ----
      1|    caught = false;
       |    try {
      1|        parse_entry(["atomico", "bad", "x", "1"]);
       |    } catch (Exception e) {
      1|        caught = true;
       |    }
      1|    assert(caught);
       |
       |    // ---- Caso: struct válido ----
      1|    parse_entry(["atomico", "u8x", "6", "8"]);
      1|    parse_entry(["atomico", "u16x", "2", "4"]);
      1|    parse_entry(["atomico", "u9x", "2", "8"]);
       |
      1|    auto out2 = parse_entry(["struct", "Pair", "u8x", "u16x", "u9x"]);
      1|    assert(out2.output == "Tipo struct creado correctamente");
      1|    assert("Pair" in global_types);
      1|    assert(global_types["Pair"].kind == TypeKind.Struct);
       |
       |    // ---- Caso: struct con tipo inexistente ----
      1|    caught = false;
       |    try {
      1|        parse_entry(["struct", "BadStruct", "noexiste"]);
       |    } catch (Exception e) {
      1|        caught = true;
       |    }
      1|    assert(caught);
       |
       |    // ---- Caso: struct repetido ----
      1|    caught = false;
       |    try {
      1|        parse_entry(["struct", "Pair", "u8x", "u16x"]);
       |    } catch (Exception e) {
      1|        caught = true;
       |    }
      1|    assert(caught);
       |
       |    // ---- Caso: unión válida ----
      1|    auto out3 = parse_entry(["union", "NumUnion", "u8x", "u16x"]);
      1|    assert(out3.output == "Tipo union creado correctamente");
      1|    assert("NumUnion" in global_types);
      1|    assert(global_types["NumUnion"].kind == TypeKind.Union);
       |
       |    // ---- Caso: unión con tipo inexistente ----
      1|    caught = false;
       |    try {
      1|        parse_entry(["union", "BadUnion2", "foo999"]);
       |    } catch (Exception e) {
      1|        caught = true;
       |    }
      1|    assert(caught);
       |
       |    // ---- Caso: unión repetida ----
      1|    caught = false;
       |    try {
      1|        parse_entry(["union", "NumUnion", "u8x"]);
       |    } catch (Exception e) {
      1|        caught = true;
       |    }
      1|    assert(caught);
       |
       |    // ---- Caso: comando inválido ----
      1|    caught = false;
       |    try {
      1|        parse_entry(["banana", "x"]);
       |    } catch (Exception e) {
      1|        caught = true;
       |    }
      1|    assert(caught);
       |
       |    // ---- Caso: argumentos insuficientes ----
      1|    caught = false;
       |    try {
      1|        parse_entry(["atomico", "x"]);
       |    } catch (Exception e) {
      1|        caught = true;
       |    }
      1|    assert(caught);
       |
      1|    caught = false;
       |    try {
      1|        parse_entry(["describir", "int"]);
      1|        parse_entry(["describir", "Pair"]);
      1|        parse_entry(["describir", "NumUnion"]);
       |    } catch (Exception e) {
0000000|        caught = true;
       |    }
       |
      1|    assert(!caught);
       |
      1|    caught = false;
       |    try {
      1|        parse_entry(["describir", "NotCreatedType"]);
       |    } catch (Exception e) {
      1|        caught = true;
       |    }
       |
      1|    assert(caught);
       |
       |    // Comando desconocido
       |    try {
      1|        parse_entry(["ComandoRaro"]);
       |    } catch (Exception e) {
      1|        caught = true;
       |    }
       |
      1|    assert(caught);
       |
      1|    out3 = parse_entry(["salir"]);
      1|    assert(out3.exit);
       |
      1|    out3 = parse_entry(["ayuda"]);
      1|    assert(out3.output == "ATOMICO <nombre> <representación> <alineación> -> \n    Evalúa la expresión [expr] que debe está en forma prefija.\nSTRUCT <nombre> [<tipo>] -> \n    Define un registro cuyos campos son tipos existentes.\nUNION <nombre> [<tipo>] -> \n    Define un registro variante cuyos campos comparten el mismo espacio.\nDESCRIBIR <nombre> -> \n    Muestra el tamaño, alineación y bytes desperdiciados del tipo.\nSALIR -> \n    Termina el programa.");
       |    
       |
      1|    writeln("Todas las pruebas del sistema de tipos pasaron correctamente.");
       |}
types.d is 91% covered
